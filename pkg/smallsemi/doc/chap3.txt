  
  [1X3 Extended Examples[0X
  
  The  main  features  of  the  library  can be summarized in three points: it
  provides a complete set of semigroups up to isomorphism and anti-isomorphism
  of  sizes up to 8; it carries a vast amount of precomputed information about
  these  semigroups;  and  there  is  an identification function which takes a
  semigroup  with  at  most 8 elements and returns a map to the equivalent one
  from the library.
  
  These features lead to different ways of using the library. It is impossible
  to  describe  -  or  even  to anticipate - all possible types of usage. Most
  problems  will  admit  multiple  solutions.  We find it difficult to predict
  which  will  be  most effective. The examples in this chapter should give an
  idea  of  the  differences  in the various functions and help you to find an
  alternative  if  a  computation  uses  more  time  or  memory  than you have
  available.
  
  Let  us  go  step by step through some ways to use the library showing which
  tools are provided.
  
  
  [1X3.1 Lists, Enumerators and Iterators of Semigroups[0X
  
  At  first  one could want to search through the stored semigroups for one or
  all semigroups with a certain property. Going through all the semigroups can
  take  a  long time. Just to create all the 1.8 billion semigroups as objects
  in  [5XGAP[0m  takes  around  a day on a modern PC. Doing a simple test on all the
  semigroups  in  the  library  might take another day. Performing complicated
  tests  easily  takes weeks. To avoid this, many properties of the semigroups
  were  precomputed.  Semigroups with or without a precomputed property can be
  accessed  as quickly as simply creating the same number of semigroups. (Note
  that  timings  of  two  calls  to  the same command may vary and, of course,
  heavily depend on your machine.)
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> # obtain a list of all semigroups with 6 elements[0X
    [4Xgap> AllSmallSemigroups( 6 );;[0X
    [4Xgap> time;[0X
    [4X2636[0X
    [4Xgap> # obtain a list of all commutative semigroups with 7 elements  [0X
    [4Xgap> AllSmallSemigroups( 7, IsCommutative, true );;[0X
    [4Xgap> time;[0X
    [4X2957[0X
    [4Xgap> # compare the numbers of semigroups in the two lists[0X
    [4Xgap> NrSmallSemigroups( 6 ); NrSmallSemigroups( 7, IsCommutative, true );[0X
    [4X15973[0X
    [4X17291[0X
  [4X------------------------------------------------------------------[0X
  
  (In  all  the  examples in this section the info messages which are given by
  default     when     data     is     loaded     are     turned    off    via
  [10XSetInfoLevel(InfoSmallSemi,0)[0m.)
  
  We  provide  three  commands  that  can  be used if one is interested in all
  semigroups  with  some  properties.  These  are  [2XAllSmallSemigroups[0m ([14X4.3-1[0m),
  [2XEnumeratorOfSmallSemigroups[0m ([14X4.3-2[0m), and [2XIteratorOfSmallSemigroups[0m ([14X4.3-11[0m).
  Which  one is best to use depends a lot on the situation. Here we attempt to
  provide some insight about the essential differences.
  
  
  [1X3.1-1 Precomputed properties[0X
  
  We  start  with  examples  using  only precomputed information. In this case
  there  is  essentially  no  advantage  of  calling an iterator instead of an
  enumerator.      Thus      only      [2XAllSmallSemigroups[0m      ([14X4.3-1[0m)     and
  [2XEnumeratorOfSmallSemigroups[0m ([14X4.3-2[0m) will be considered.
  
  We  first  compare  the  memory  usage  and  the  setup  time. Assume we are
  interested in the commutative semigroups with at most 7 elements.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> list := AllSmallSemigroups([1..7],IsCommutativeSemigroup,true);;[0X
    [4Xgap> time; # the time needed will always depend on your machine[0X
    [4X3180[0X
    [4Xgap> enum := EnumeratorOfSmallSemigroups([1..7],IsCommutativeSemigroup,true);[0X
    [4X<enumerator of semigroups of sizes [ 1 .. 7 ]>[0X
    [4Xgap> time;[0X
    [4X8[0X
  [4X------------------------------------------------------------------[0X
  
  The  enumerator  stores  the  information, which semigroups it contains, but
  only creates the semigroups when asked for them explicitly.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> # now the semigroups have to be created ...[0X
    [4Xgap> for sg in enum do[0X
    [4X# do nothing, the semigroup will be created anyway[0X
    [4Xod;[0X
    [4Xgap> time;[0X
    [4X3428[0X
    [4Xgap> # ... and again if you want to look through them another time ...[0X
    [4Xgap> for sg in enum do[0X
    [4Xod;[0X
    [4Xgap> time;[0X
    [4X3437[0X
    [4Xgap> # ... not so for the list of semigroups though[0X
    [4Xgap> for sg in list do[0X
    [4Xod;[0X
    [4Xgap> time;[0X
    [4X4[0X
  [4X------------------------------------------------------------------[0X
  
  There  are  several reasons why one would nevertheless prefer an enumerator,
  one  is  the smaller need for memory. While the number of semigroups in this
  example is rather moderate (compared with all the semigroups in the library)
  the difference is remarkable:
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> nr := Length(enum);[0X
    [4X17291[0X
    [4Xgap> MemoryUsage(enum);                                 [0X
    [4X70507[0X
    [4Xgap> MemoryUsage(list); # this will take a while ...[0X
    [4X19089280[0X
    [4Xgap> # ... but you can get a close approximation much faster[0X
    [4Xgap> sg := OneSmallSemigroup(7,IsCommutativeSemigroup,true);[0X
    [4X<small semigroup of size 7>[0X
    [4Xgap> nr*MemoryUsage(sg);[0X
    [4X19020100[0X
  [4X------------------------------------------------------------------[0X
  
  As  said before the advantage of the enumerator comes from the fact that the
  members of it are created anew every time they are called. This means on the
  other hand that information that is computed is not stored.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> IsZeroSemigroup(list[3]); # a semigroup from the list ...[0X
    [4Xfalse[0X
    [4Xgap> KnownPropertiesOfObject(list[3]); # ... can store new information[0X
    [4X[ "IsEmpty", "IsTrivial", "IsNonTrivial", "IsFinite", "IsDuplicateFree", [0X
    [4X  "IsAssociative", "IsCommutativeSemigroup", "IsZeroSemigroup" ][0X
    [4Xgap> IsZeroSemigroup(enum[3]); # semigroups in the enumerator ...[0X
    [4Xfalse[0X
    [4Xgap> KnownPropertiesOfObject(enum[3]); # ... are created anew in every call [0X
    [4X[ "IsEmpty", "IsTrivial", "IsNonTrivial", "IsFinite", "IsDuplicateFree", [0X
    [4X  "IsAssociative", "IsCommutativeSemigroup" ][0X
    [4Xgap> # but if it turns out this is the semigroup you want to analyse, just do[0X
    [4Xgap> sg := enum[3];[0X
  [4X------------------------------------------------------------------[0X
  
  Observe  that  in  the  last  example the semigroup from the enumerator knew
  about  the  property  that was used to create the enumerator. The enumerator
  stores this knowledge and passes it on whenever a member is called.
  
  Another  reason to prefer an enumerator is that one might only be interested
  in some of the elements it contains. This could become clear after analysing
  some  of  the  elements  and  then  there  is no time wasted in creating all
  semigroups  in the enumerator. Or possibly creating the enumerator involving
  precomputed  properties was just the first step. As described in Section [14X4.3[0m
  enumerators  themselves can be given as argument to get to a more restricted
  class of semigroups. This leads us to the next part of this section.
  
  
  [1X3.1-2 User functions[0X
  
  We  now  come to examples dealing with properties that are not precomputed -
  including  user  defined  functions.  This  makes  [2XIteratorOfSmallSemigroups[0m
  ([14X4.3-11[0m)  interesting  again.  Assume  you  want  to work with bands ([2XIsBand[0m
  ([14X4.2-4[0m))  of  order  8  having  1  Green's  D-class (see [14X'Reference: Green's
  Relations'[0m).  You  might  feel  tempted  to  implement  a function testing a
  semigroup for this combination of properties.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> isFascinatingSemigroup := function(sgrp)[0X
    [4Xlocal dclasses;[0X
    [4Xdclasses := GreensDClasses(sgrp);[0X
    [4Xreturn IsBand(sgrp) and Length(dclasses) = 1;[0X
    [4Xend;[0X
  [4X------------------------------------------------------------------[0X
  
  But  then  the  precomputed  property  [2XIsBand[0m  ([14X4.2-4[0m) is hidden inside your
  function  and  a call like [10XAllSmallSemigroups(8,isFascinatingSemigroup,true)[0m
  would take days to complete.
  
  The following finds the same semigroups more efficiently:
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> list:=AllSmallSemigroups(8,IsBand,true,x->Size(GreensDClasses(x)),1);[0X
    [4X[ <small semigroup of size 8>, <small semigroup of size 8> ][0X
    [4Xgap> time;[0X
    [4X49211[0X
    [4Xgap> enum:=EnumeratorOfSmallSemigroups(8,IsBand,true,x->Size(GreensDClasses(x)),1);[0X
    [4X<enumerator of semigroups of size 8>[0X
    [4Xgap> time;[0X
    [4X48723[0X
  [4X------------------------------------------------------------------[0X
  
  Observe  that  the  enumerator  lost  its  advantage of returning the answer
  faster because not all properties are precomputed. Thus all bands have to be
  constructed  to  test  their  number  of  D-classes.  As  the number of such
  semigroups is small, [2XAllSmallSemigroups[0m ([14X4.3-1[0m) is the better choice in this
  example  -  remember  that  the  semigroups  from  the enumerator have to be
  recreated  in  every  call.  Often  one does not have this kind of knowledge
  beforehand.  Even  for a large number of semigroups the enumerator still has
  the  advantage  of  using  far  less memory as it stores only the IDs of the
  semigroups. Before explaining more about this let us for a moment go back to
  the  semigroups  from  the  previous  example.  It  turns out they are the 2
  non-equivalent   rectangular   bands  ([2XIsRectangularBand[0m  ([14X4.2-21[0m))  with  8
  elements.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> ForAll(list,IsRectangularBand);[0X
    [4Xtrue[0X
  [4X------------------------------------------------------------------[0X
  
  As  a last example in this subsection we look at semigroups from the library
  that  are  not nilpotent. As there are quite some of these we will first try
  an enumerator. The obvious call seems to be
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> enum1 := EnumeratorOfSmallSemigroups([1..7],IsNilpotentSemigroup,false);[0X
    [4X<enumerator of semigroups of sizes [ 2, 3, 4, 5, 6, 7 ]>[0X
    [4Xgap> time;[0X
    [4X103403[0X
  [4X------------------------------------------------------------------[0X
  
  However,  we  would  like  to  include the semigroups of order 8 as well. As
  [2XIsNilpotentSemigroup[0m  ([14X4.2-19[0m)  is not a precomputed property in the current
  version  of  [5XSmallsemi[0m  this  would  take  a  long  time.  Here,  additional
  knowledge,  about  the  way  the  semigroups  are  stored in the library, is
  helpful.  The description of [2XNilpotencyRank[0m ([14X4.2-33[0m) contains information on
  the  IDs  of  all  3-nilpotent  semigroups  of  order  8.  We  can create an
  enumerator without those semigroups doing the following:
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> # all 8 element semigroups that are not 3-nilpotent[0X
    [4Xgap> enum2 := EnumeratorOfSmallSemigroupsByIds([8],[[1..11433106]]);[0X
    [4X<enumerator of semigroups of size 8>[0X
  [4X------------------------------------------------------------------[0X
  
  Out  of  this  enumerator  the  subclass  of not nilpotent semigroups can be
  extracted.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> enum3 := EnumeratorOfSmallSemigroups(enum2,IsNilpotentSemigroup,false);[0X
    [4Xgap> # This still takes quite a while though[0X
    [4Xgap> time;[0X
    [4X1931140[0X
  [4X------------------------------------------------------------------[0X
  
  You  can  avoid the waiting time at setup by using an iterator instead of an
  enumerator. An iterator does not know how many elements it contains, one can
  always  just  access  the  next element - if such exists - and one cannot go
  back. (Making copies of an iterator can help to circumvent this problem.) On
  the  other hand one could in the above example start investigating the first
  couple of elements right away.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> iter := IteratorOfSmallSemigroups(enum2,IsNilpotentSemigroup,false);[0X
    [4X<iterator of semigroups of size 8>[0X
    [4Xgap> for i in [1..100000] do [0X
    [4XNextIterator(iter);[0X
    [4Xod;[0X
    [4Xgap> time;[0X
    [4X30785[0X
  [4X------------------------------------------------------------------[0X
  
  But  even  if  you  know  you  want  to  inspect all the semigroups having a
  property  which  is  not  precomputed, an iterator has the advantage that it
  does  not  create  the semigroups before you can actually work with them. To
  create  an  enumerator  all  semigroups in question will be created and - as
  said before - every element is created anew when it is accessed. An iterator
  on  the other hand creates the semigroups in question one-by-one and returns
  the  next one having the property. This makes a big difference if the number
  of  semigroups  one  is  interested  in  is  big  like in the example of not
  nilpotent  semigroups  of size 8. In the former example with the rectangular
  bands  it  would  not play a role and the disadvantages of an iterator would
  prevail.
  
  As  you  can see the number of semigroups you are interested in is even more
  important  in the case of user defined functions than it was in the previous
  section  about precomputed properties. Sometimes you might have a rough idea
  about  the  numbers  -  or  even  a  very good one - to base your choice on.
  Otherwise  the best approach seems to consist of two steps. First, create an
  enumerator involving all precomputed properties (try to find as many implied
  properties  as  possible).  Then  work with an iterator, call the semigroups
  one-by-one  and store them in a separate list if you think you might want to
  look at them again at a later stage.
  
  
  [1X3.1-3 Semigroups of order 8[0X
  
  When using enumerators and iterators of semigroups of order 8 there are some
  limitations.  In a 32-bit system the number of semigroups of order 8 exceeds
  the  maximal  length  of  a list in [5XGAP[0m. The following will work in a 64-bit
  system, but not on a 32-bit system.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> EnumeratorOfSmallSemigroups(8);[0X
  [4X------------------------------------------------------------------[0X
  
  In  all  other  cases  there  is  currently no difference between 32-bit and
  64-bit systems. Hence the following will fail in any case.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> EnumeratorOfSmallSemigroups(8,IsCommutativeSemigroup,false);[0X
  [4X------------------------------------------------------------------[0X
  
  Note  though  that  an enumerator of semigroups of order 8 can be created if
  one  of the required properties is precomputed and takes [10Xtrue[0m as value. This
  fact  was  used  in the previous subsection, when creating the enumerator of
  all bands of order 8 having 1 Green's D-class.
  
  One  could  try to circumvent the described problem by using a iterator. The
  command
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> iter := IteratorOfSmallSemigroups(8,IsCommutativeSemigroup,false);[0X
    [4X<iterator of semigroups of size 8>[0X
  [4X------------------------------------------------------------------[0X
  
  will  succeed.  But  running through the elements in the iterator can take a
  long  time  since the precomputed information is not utilized. A better idea
  in the current version of [5XSmallsemi[0m is to divide the enumerator into smaller
  pieces  by restricting the range of IDs considered at once to at most 2^28-1
  (the  maximal  length  of  a  list in a 32-bit [5XGAP[0m) or possibly by a smaller
  value,  depending  on  the  amount of memory you have available. For example
  start with
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> enum1 := EnumeratorOfSmallSemigroupsByIds([8],[[1..2^24-1]]);[0X
    [4X<enumerator of semigroups of size 8>[0X
    [4Xgap> enum2 := EnumeratorOfSmallSemigroups(enum1, IsCommutativeSemigroup, false);[0X
    [4X<enumerator of semigroups of size 8>[0X
  [4X------------------------------------------------------------------[0X
  
  Thanks  go  to  Michal  Stolorz  for  the  idea of circumventing the current
  performance  issue  for  enumerators  of  small  semigroups  of  order  8 by
  splitting it in the described way.
  
  
  [1X3.2 Identifying Semigroups[0X
  
  The  data  in  [5XSmallsemi[0m  is  as  a big catalogue of all structural types of
  semigroups  with at most 8 elements making it possible to refer to the types
  by  their  catalogue  number,  that  is  by  their ID. With [2XIdSmallSemigroup[0m
  ([14X4.1-6[0m) one can find the ID of the structural type of a particular semigroup
  with at most 8 elements.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> t1 := RandomTransformation(3);[0X
    [4XTransformation( [ 1, 3, 1 ] )[0X
    [4Xgap> t2 := RandomTransformation(3);[0X
    [4XTransformation( [ 1, 2, 3 ] )[0X
    [4Xgap> sgrp := SemigroupByGenerators([t1,t2]);[0X
    [4X<semigroup with 2 generators>[0X
    [4Xgap> Size(sgrp);[0X
    [4X3[0X
    [4Xgap> IdSmallSemigroup(sgrp);[0X
    [4X[ 3, 8 ][0X
  [4X------------------------------------------------------------------[0X
  
  Moreover, one can draw conclusions about a semigroup of size at most 8 using
  the precomputed information about the equivalent semigroup from the library.
  The   precomputed   properties  are  all  invariant  under  isomorphism  and
  anti-isomorphism.  This  is most useful in the case where there is no method
  in  [5XGAP[0m  to  decide  the  property  in  the  original  representation of the
  semigroup.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> # use the semigroup from the previous example[0X
    [4Xgap> IsCommutative(sgrp); # no need to use the library for this[0X
    [4Xtrue[0X
    [4Xgap> # for the following there exists no method for a trans-[0X
    [4Xgap> # formation semigroup; access the precomputed information instead [0X
    [4Xgap> IsMultSemigroupOfNearRing(SmallSemigroup([3,8]));[0X
    [4Xfalse[0X
  [4X------------------------------------------------------------------[0X
  
  [2XEquivalenceSmallSemigroup[0m   ([14X4.1-7[0m)   even   provides   an   isomorphism  or
  anti-isomorphism  to  a  semigroup  from the library. This means one can map
  elements  between  the  semigroups. Remember that an isomorphism is returned
  whenever  one  exists. This allows to distinguish between structure types up
  to  isomorphism.  Note  though, that no information about subsets - like the
  set  of  idempotents  or a generating set - is precomputed for semigroups in
  the  library. If an operation has a method for the semigroup in the original
  representation, it is usually more sensible to simply call this.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> t1 := RandomTransformation(3);[0X
    [4XTransformation( [ 2, 2, 1 ] )[0X
    [4Xgap> t2 := RandomTransformation(3);[0X
    [4XTransformation( [ 2, 1, 1 ] )[0X
    [4Xgap> sgrp := SemigroupByGenerators([t1,t2]);[0X
    [4X<semigroup with 2 generators>[0X
    [4Xgap> Size(sgrp);[0X
    [4X6[0X
    [4Xgap> map := EquivalenceSmallSemigroup(sgrp); [0X
    [4XMappingByFunction( <semigroup with 2 generators>, <small semigroup of size [0X
    [4X6>, function( x ) ... end )[0X
    [4Xgap> RespectsMultiplication(map); # verify that this is an anti-isomorphism[0X
    [4Xfalse[0X
    [4Xgap> MinimalGeneratingSet(Range(map));[0X
    [4X[ s2, s4 ][0X
    [4Xgap> PreImage(map,last); # get a minimal generating set of <sgrp>[0X
    [4X[ Transformation( [ 1, 1, 2 ] ), Transformation( [ 2, 1, 1 ] ) ][0X
    [4Xgap> Idempotents(Range(map));[0X
    [4X[ s1, s3, s5 ][0X
    [4Xgap> PreImage(map,last); # in the same way you can get the idempotents ...[0X
    [4X[ Transformation( [ 1, 1, 1 ] ), Transformation( [ 1, 2, 2 ] ), [0X
    [4X  Transformation( [ 2, 2, 2 ] ) ][0X
    [4Xgap> Idempotents(sgrp); # ... but this can be done directly instead [0X
    [4X[ Transformation( [ 1, 1, 1 ] ), Transformation( [ 1, 2, 2 ] ), [0X
    [4X  Transformation( [ 2, 2, 2 ] ) ][0X
  [4X------------------------------------------------------------------[0X
  
  If  for  a  certain  application  you are interested in the semigroups up to
  isomorphism  you  can  still  use the IDs from [5XSmallsemi[0m. Simply mark the ID
  with  *, or however else you denote the dual of a semigroup, to refer to the
  semigroup  being  anti-isomorphic  to the one in the library having the same
  ID.  For  all  semigroups  [2XIsSelfDualSemigroup[0m ([14X4.2-24[0m) is precomputed. This
  will  help  to  decide  whether  a  semigroup  and  its  dual  are  actually
  non-isomorphic.
  
